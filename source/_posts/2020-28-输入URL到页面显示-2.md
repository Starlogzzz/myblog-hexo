---
title: 输入URL到浏览器显示经历了什么(2)
date: 2020-11-22 15:07:50
tags:
  - 浏览器
  - 网络
categories: 
  - 浏览器
  - 网络
cover: https://s3.ax1x.com/2020/11/20/DQwbfs.md.jpg
abbrlink: 202028
---

# 前言
上一篇内容很少，主要是总结了网络相关的内容，也包括浏览器缓存这些，这篇主要讲浏览器的渲染流程（PS：最近更新node到14.15版本之后hexo的打包功能就有问题了，搞了好长时间才修复，555）

# 大体步骤
+ 构建 DOM 树
+ 样式计算
+ 布局阶段
+ 分层
+ 生成绘制列表
+ 分块
+ 合成

接下来我们来一一讲解

# 构建DOM树
因为浏览器是看不懂html代码的，所以它需要先将html转换为dom树，我们可以在Chrome控制台的Console部分输入` document `来查看这个网页的DOM树结构。

# 样式计算
因为我们的网页不仅有结构还有样式，所以我们需要计算出DOM节点中元素的具体样式，从而展示它们。而浏览器也是不认识CSS代码的，所以需要将CSS转换为CSSOM，也就是` styleSheets `。

## 样式标准化
解析生成CSSOM的时候，有些单位并不能被浏览器的渲染引擎理解，比如
```css
.tabbar {
  font-size: 2em;
  color: red;
  font-weight: bold;
}
```
这里的三个数值` 2em, red, bold `都是渲染引擎懂得，我们要将它们转换为` 28px, rgb(255, 0, 0), 700 `这种值，这就是**样式标准化**

## 计算具体样式
经历了样式标准化之后，我们的渲染引擎已经可以看懂CSS代码了，我们就要具体计算DOM树中每一个节点的样式了，首先会查看**继承关系**。比如我们上面在` tabbar `中设置的三个样式，它们都可以被继承，我们会根据DOM节点的继承关系来计算节点样式。除了继承之外，我们还要查看CSS的**层叠关系**，这里不过多介绍。

# 布局阶段
通过上述操作，我们已经获得了一棵DOM树，和CSSOM生成树，但我们还需要计算DOM元素具体的几何位置，才能显示它们，这就是布局阶段处理的事情。可以理解为把DOM树和CSSOM树结合。

## 创建布局树
我们结合DOM树和CSSOM生成树，形成一棵布局树，具体的操作是遍历DOM树将可见节点(` display: none `这种就是不可见节点)添加到布局树中

## 布局计算
在执行布局操作的时候，会把布局运算的结果重新写回布局树中，这就是布局计算，但这个过程十分复杂，并且Chrome团队正在重构布局代码。

# 分层
浏览器的渲染引擎会把特点的节点生成一个图层，并且生成一棵图层树，一棵布局树就对应一棵图层树，其中如果一个节点没有对应的图层，那么这个节点就属于父节点的图层，渲染引擎创建图层的条件如下：

+ 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)的属性单独一层
+ 需要裁切的地方会创建一层
代码如下，代码中div的文字提供演示，与本文内容无关。
因为div中内容过多，超出了我们设置的面积，这样就会出现裁切，这种情况时，文字部分会单独创建一层，进度条也会单独创建一层。
```html
<style>
  div {
    width: 100px;
    height: 100px;
    border: 1px solid #ccc;
    overflow: auto;
    background-color: palegoldenrod;
  }
</style>
<div>
  font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的母与其余文本相比，其字体尺寸更小。
  color：文本颜色
  7、光标属性：cursor
  8、页面样式属性：page、page-break-inside、windows、orphans
  9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-familypitch、pitch-range、stress、richness、、azimuth、elevation
</div>
```
我们可以通过浏览器调试工具来查看它的分层，如图所示
[![D8y9OJ.png](https://s3.ax1x.com/2020/11/22/D8y9OJ.png)](https://imgchr.com/i/D8y9OJ)
[![D8szSU.png](https://s3.ax1x.com/2020/11/22/D8szSU.png)](https://imgchr.com/i/D8szSU)

# 生成绘制列表
渲染引擎实现图层的绘制时，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，绘制列表如图所示[![D8yxAI.png](https://s3.ax1x.com/2020/11/22/D8yxAI.png)](https://imgchr.com/i/D8yxAI)，而绘制操作是由渲染引擎中的合成线程来完成的。

# 分块
合成线程拿到这个绘制列表之后就要进行操作来生成页面，最后发送给GPU，但一个页面并不是一口气绘制出来的，比如一些比较长的页面，我们需要将它分成多个` 图块 `，渲染进程中专门维护了一个` 栅格化线程池 `，专门负责把图块转换为位图数据。优先转换视口附近的图块。生成位图的过程实际上都会使用GPU进行生成，生成的位图最后发送给合成线程。

# 合成
所有图块被光栅化之后，合成线程生成一个绘制图块的命令` DrawQuad `把它交给浏览器进程，浏览器进程里面的` viz `组件根据收到的` DrawQuad `命令，将内容绘制到内存，最后显示到屏幕上。

整个过程如图所示[![D8Xnm9.png](https://s3.ax1x.com/2020/11/22/D8Xnm9.png)](https://imgchr.com/i/D8Xnm9)

# 重绘和回流
梳理完整个过程我们再来看一下重绘和回流会经历什么，先说重绘

## 重绘
重绘只是改变元素的颜色，并不会影响布局，所以一次重绘仅仅需要执行图中红色的两步。[![D8v1MD.png](https://s3.ax1x.com/2020/11/22/D8v1MD.png)](https://imgchr.com/i/D8v1MD)

## 回流（重排）
回流影响了布局，所以要重走一次完整的流水线，所以它的开销是很大的。

# 合成
那如果更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。所以我们使用CSS的` transform `来实现动画效果，可以避开回流和重绘，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和回流，合成能大大提升绘制效率。

# 总结
大概总结一下从输入URL到页面展示的整个流程
1. 查缓存，有缓存走缓存，没缓存就发请求
2. DNS解析，TCP三次握手，发送HTTP请求
3. 客户端拿到响应数据，准备解析
4. 构建DOM树，同时进行样式计算，生成CSSOM
5. 合成DOM树和CSSOM树，生成布局树，计算布局信息
6. 对布局树进行分层，并生成分层树
7. 为每个图层生成绘制列表，并将其提交到合成线程
8. 合成线程将图层分为多个图块，再使用光栅化线程池将图块转为位图
9. 合成线程生成命令` DrawQuad `把它交给浏览器进程，浏览器线程通过` viz `把内容显示在页面上