---
title: 2020-23-V8垃圾回收机制
date: 2020-10-27 09:34:26
tags:
  - React
categories: 
  - React
cover: https://s1.ax1x.com/2020/10/27/BM3DHJ.jpg
abbrlink: 202023
---

# 前言
本文章来源于三元大佬写的V8垃圾回收机制，自己理解后自己总结的一篇文章，[原文出处](http://47.98.159.95/my_blog/js-v8/002.html#v8-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6)。

# V8垃圾回收

JS语言比较类似于JAVA，它有一套自己的垃圾回收机制，并不需要像C/C++一样去手动清除垃圾。

## V8内存限制

在JS中，V8只能使用电脑内存的一小部分，在64位系统下，最多只能分配大约1.4G内存。

## 栈内存垃圾回收

栈内存的垃圾回收机制其实非常简单，就是任务执行完成后从栈顶出栈，内存被回收。

## 堆内存垃圾回收

那么问题来了，为什么要给V8设置内存上限呢？主要分为两点：

1. JS是单线程的
2. JS的垃圾回收机制的限制

逐一解释，因为JS是单线程的，所以说在垃圾回收环节会阻断其他任务的执行，只能等待垃圾回收完成之后再回复，但实际上V8的垃圾回收是很耗时的，V8 官方是这样形容的:

>  以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。

在这么长一段时间内我们的的代码是不会执行的，会造成卡顿，因此V8使用了一种简单粗暴的手段，那就是限制内存。其实V8也给我们留下了方法去更改内存的限制大小，这里先不提及。

## 新生代内存的回收

V8把堆内存分为新生代内存和老生代内存，新生代就是临时创建的内存，存活时间比较短，而老生代则是常驻内存，存活时间长。[![BuvzVI.png](https://s1.ax1x.com/2020/10/26/BuvzVI.png)](https://imgchr.com/i/BuvzVI)

针对这两种内存，V8采用两种不同的回收策略。

<hr/>

新生代内存在64位和32位系统下默认限制为32MB和16MB。因为新生代内存存活时间比较短，一般不会产生太大的内存负担，所以把它设置得这么小。接下来展示如何回收新生代内存。

首先新生代内存空间可以分为两个部分。[![BuxNIx.png](https://s1.ax1x.com/2020/10/26/BuxNIx.png)](https://imgchr.com/i/BuxNIx)

From部分表示正在使用的内存，而To部分表示目前闲置的内存。

当进行垃圾回收时，V8将From部分进行排查，如果是存活的对象那么把它复制到To内存中，在To中按照顺序从头放置，如果不是存活对象那就直接消灭。

当所有From中存活的对象被放置到To之后，From和To两者对调，From变为闲置的内存，To变为正在使用的内存，如此循环。有点像用砂纸过滤液体里的杂质一样，反复过滤。

那为什么不直接回收不使用的内存，而是这么麻烦呢？因为我们把存活的对象放在To中是按照顺序从头排序的。（这里打个比方，比如你和我正在下围棋，我们下完一局之后棋盘被白子和黑子覆盖了大部分区域，比如说黑子是不使用的要被清除的对象，而白子是存活的对象，我们要是直接清除黑子，那么这个棋盘就会变得非常不工整，就像这样[![BKSzZ9.png](https://s1.ax1x.com/2020/10/26/BKSzZ9.png)](https://imgchr.com/i/BKSzZ9)

红色代表白子，假如这时我们来了一个很耗费内存的应用，类似于一个大小为正常棋子四倍的黑子，那他就没地方放置了，所以我们要把所有白子全部拿到另一张棋盘上，从头按顺序一一防止，再把黑子清除，如此循环）这种零散的空间也叫做**内存碎片**，刚刚介绍的新生代垃圾回收算法也叫**Scavenge算法**。（这个单词的意思是捡破烂）不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象`一般很少`，因此`时间`性能非常优秀。

## 老生代内存的回收

现在该思考老生代内存了，首先要知道新生代内存变为老生代内存的条件：

- 已经经历过一次 Scavenge 回收。
- To（闲置）空间的内存占用超过25%。

老生代内存是不会使用Scavenge算法的，因为老生代内存是很大的，不便于像新生代内存一样复制。这里采用的方案其实就是我们老生常谈的**标记-清除**了。主要分为三个阶段

+ 阶段1：对所有对象进行标记
+ 阶段2：把正在使用的变量和被强引用的变量取消标记
+ 阶段3：删除仍有标记的变量

当然这样做仍会有上面在新内存中提到的内存碎片的问题，这里V8直接暴力的在清除工作结束后，将存活的对象全部往一侧靠拢。因为是直接移动对象，所以执行速度不快，事实上也是整个过程中最耗时间的部分。

## 增量标记

由于JS的单线程机制，V8在垃圾回收的时候会阻塞业务代码的执行，如果这段时间很长，那么会严重影响性能，所以V8将大任务分成很多个小任务，每做完一个小任务就用一段时间去执行业务代码，如此循环。经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。
