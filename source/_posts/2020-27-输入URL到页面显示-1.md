---
title: 输入URL到浏览器显示经历了什么(1)
date: 2020-11-19 14:54:31
tags:
  - 浏览器
  - 网络
categories: 
  - 浏览器
  - 网络
cover: https://s3.ax1x.com/2020/11/20/DQwbfs.md.jpg
abbrlink: 202027
---

# 前言
这是一个非常经典的问题，可以说是面试必问（但我好像没被问过几次，哈哈），今天来完全梳理一下整个流程，理解透彻这个问题可以帮助我们更好的优化我们的项目，解决一些疑难杂症，这篇文章主要是讲网络方面。

# 进程
我们都知道Chrome浏览器问世之时就是因为它的多进程架构秒杀掉了其他单进程架构的浏览器。而目前的Chrome已经拥有`渲染进程`,`网络进程`,`浏览器主进程`,`GPU进程`,`插件进程`。其中渲染进程和插件进程拥有多个，下面来简单介绍一下它们的功能。
+ 浏览器进程：主要负责界面的显示，用户交互，子进程的管理，存储功能等。
+ 渲染进程：将HTML，CSS，JS转换为页面，默认情况下Chrome会给每个页面创建一个渲染进程。
+ GPU进程：用于显示页面（以前是没有的，后加进来的，看网页也得买个好显卡）
+ 网络进程：负责页面网络资源加载
+ 插件进程：负责运行插件，如果插件崩溃，因为它是在单独线程中的，所以不会对页面和浏览器造成影响。

<hr/>
因为发送网络请求也是需要进程配合的，所以刚才简单介绍了一下浏览器进程。大概的步骤为输入一个URL之后，浏览器进程将URL发送给网络进程，网络进程发送网络请求，拿到响应头数据后交给浏览器进程，浏览器进程再告诉渲染进程去渲染，渲染进程建立起和网络进程的管道，渲染进程获取HTML数据，然后告诉浏览器进程我已就位随时起飞，然后浏览器进程开始移除老的文档，准备更新页面。
听起来确实挺麻烦的，这一部分了解即可。应该也没人会问。

# 浏览器缓存
用户输入URL之后，浏览器进程通过IPC发送URL给网络进程，网络进程收到URL之后首先查看本地是否有**缓存资源**，首先检查**强缓存**，没有再检查**协商缓存**。

## 强缓存
具体检查的是响应头中的` Expires `和` Cache-Control `字段，HTTP1.0中使用` Expires `而因为` Expires `有一些问题，所以HTTP1.1引入了` Cache-Control `。

### Expires
这个单词是过期的意思，它的含义也是设置一个` 过期时间 `，如果客户端与服务器的时间不相同，那么就会出现了一些BUG。
` expires: Mon, 30 Nov 2020 12:12:58 GMT `
它的意思是在2020年11月30号也就是下周一12:12:58过期。

### Cache-Control
上面说了` expires `是有问题的，所以我们引入了` Cache-Control `，它设置的是有效时长而非过期时间。
` cache-control: max-age=5184000 `
表示这个这个文件可以缓存5184000秒。这样就不会出现上面的问题了。而且如果响应头中同时存在这个两个字段，那么` Cache-Control `的优先级是大于` expires `的。这个字段还有一些其他属性，比如：
+ public  所有内容都将被缓存(客户端和代理服务器都可缓存)
+ private	 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)
+ no-cache	跳过强缓存，直接发送HTTP请求，进入协商缓存
+ no-store	所有内容都不会被缓存到缓存或 Internet 临时文件中
+ s-maxage  作用和max-age一样，但只对代理服务器生效

## 协商缓存
如果我们没找到强缓存，或者强缓存已经过期，那么就到协商缓存这里，顾名思义，我们要先协商一下，再决定是否走缓存。浏览器会在请求头中携带一个` Tag `服务器根据这个tag判断是否使用缓存，当然这个tag是我们第一次请求网页时服务器给我们传过来的，tag分为` last-modified `和` etag `。

### last-modified
最后修改时间，浏览器第一次请求数据得到这个tag之后再次请求服务器，会在请求头中携带一个` If-Modified-Since `字段，记录着上一个last-modified中的时间。服务器拿到` If-Modified-Since `字段后，服务器比较它和服务器中该资源的最后修改时间。如果发来的时间小于最后修改时间，那么需要更新资源，所以服务器返回最新资源给客户端。否则返回304通知浏览器缓存还可用。

### etag
服务器当前文件的内容的一个唯一表示，每次修改文件都会再生成一个新的表示，类似于hash。浏览器第一次接收到这个字段之后，每次请求会在` If-None-Match `字段上携带它。发送给服务器，服务器拿到之后比较两者的标识是否一致，一致则返回304告知浏览器缓存可用，否则返回新资源。

两者并不像上面的expires和Cache-control。etag和last-modified各有好处，last-modified性能高于etag，而etag比last-modified更精准。但etag优先级大于last-modified。

# DNS解析
因为我们输入URL并不是IP，所以我们要通过DNS来进行域名解析，将URL解析成IP地址，DNS还有缓存，假如我们之前搜素过这个URL，那么下一次不会再去解析，而是直接获取上一次的解析结果。

# TCP连接
Chrome同一域名最多只能建立6个TCP链接，TCP连接会先进行三次握手，三次握手的目的是为了让发送方和接收方知道双方都有` 接收和发送数据的能力 `。具体可以看这张图
[![DQwYFJ.png](https://s3.ax1x.com/2020/11/20/DQwYFJ.png)](https://imgchr.com/i/DQwYFJ)
之后就可以进行数据传输了。传输完成之后四次挥手断开连接。

# HTTP请求
TCP三次握手之后，浏览器就会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

# 响应
服务器解析我们发送的请求，之后发送资源到浏览器。响应完成之后查看` Connection `字段是否为` Keep-Alive `是的话就保持连接，否则断开TCP连接。

# 重定向
若服务器发返回给我们的状态码为301或者302，那么就要在响应头中查找` location `字段，获取重定向的地址，再发送网络请求到这个地址。你可以搜索360buy.com，来查看响应信息，它会重定向到京东的首页。

> 参考文章：[浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)